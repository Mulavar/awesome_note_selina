## Java线程

java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统介入，需要在户态与核心态之间切换，这种切换会消耗大量的系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。

如果线程状态切换是一个高频操作时，这将会消耗很多CPU处理时间；
如果对于那些需要同步的简单的代码块，获取锁挂起操作消耗的时间比用户代码执行的时间还要长，这种同步策略显然非常糟糕的。



根据锁的重量级，可以分为：

- 偏向锁
- 轻量锁
- 重量锁



Java对象在JVM中的存储可以分为三部分：

- **Java对象头**，又包含：
    - markword：包含锁类型标志、偏向锁指向线程id、gc年龄等信息
    - class pointer：指向类信息的指针
- Java对象实例信息
- 填充字段

如图所示

![markword](../../resources/markword.png)

注：

- 包含hash字段的表示的无锁状态是**偏向锁被禁用时**的情况；
- 偏向机制被启用时，分配出来的对象状态是 `ThreadId|Epoch|age|1|01`, **ThreadId 为空时标识对象尚未偏向于任何一个线程**， ThreadId 不为空时， 对象既可能处于偏向特定线程的状态， **也有可能处于已经被特定线程占用完毕释放的状态**， 需结合 Epoch 和其他信息判断对象是否允许再偏向（rebias）。
- epoch只有偏向锁有，是用于判断偏向锁是否仍有效引入的一个时间戳概念。



## 偏向锁

偏向锁的对象的markword会存有持有该锁的线程ID，当每次线程尝试获取锁时，比较ID：

- 若相同则直接成功，
- 若不同则是线程发生了竞争，需要升级为轻量锁。



## 轻量锁

获取到轻量锁的线程会在自己的栈帧中划出一块空间作为**lock record**，然后使用**CAS**将对象的markword替换为该**lock record**的指针。

![轻量级锁](../../resources/轻量级锁lockRecord.png)

CAS是**自旋锁**，当一个线程锁获取轻量锁失败时，他会不断自旋（死循环浪费cpu时间），自旋过久（可能**多个线程竞争导致有个线程一直获取不到锁，一直在自旋**）时间耗费的资源会超过线程挂起，则这时我们需要把轻量级锁升级为重量级锁，并把线程挂起。



## 重量锁

依赖于操作系统的互斥量（mutex）实现，每次获取锁失败会挂起，导致内核态和用户态的切换。



[参考资料1](https://blog.csdn.net/lengxiao1993/article/details/81568130)

[参考资料2](https://blog.csdn.net/zqz_zqz/article/details/70233767)

[Java锁合集资料](https://tech.meituan.com/2018/11/15/java-lock.html)



