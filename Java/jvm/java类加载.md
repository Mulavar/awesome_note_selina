JVM 虚拟机执行 class 字节码的过程可以分为七个阶段：**加载、验证、准备、解析、初始化、使用、卸载。**



* [加载](#加载)
* [验证](#验证)
* [准备](#准备)
* [解析(不重要)](#解析不重要)
* [初始化(重点)](#初始化重点)
* [使用](#使用)
* [卸载](#卸载)
* [结论](#结论)
* [参考资料](#参考资料)



### 加载

JVM 的主要目的是将字节码从各个位置（网络、磁盘等）转化为二进制字节流加载到内存中，接着会为这个类在 JVM 的方法区创建一个对应的 **Class 对象**，**这个 Class 对象就是这个类各种数据的访问入口**。具体过程如下：

1. 通过类全限定名获取字节流
2. 将字节流载入转为方法区的运行时数据结构



### 验证

**JVM规范校验**。JVM 会对字节流进行文件格式校验，判断其是否符合 JVM 规范，是否能被当前版本的虚拟机处理。

**代码逻辑校验**。JVM 会对代码组成的数据流和控制流进行校验，确保 JVM 运行该字节码文件后不会出现致命错误。(**IDE或编译阶段的javac也有类似的作用**)



### 准备

完成字节码校验后，JVM开始为**类变量**分配内存并初始化。值得注意的是，**内存分配的对象**和**初始化类型**都有两种：

+ **内存分配的对象**：

    + 类变量：被 `static` 修饰的变量
    + 类成员变量

    在准备阶段，JVM 只会为「类变量」分配内存，而不会为「类成员变量」分配内存。「类成员变量」的内存分配需要等到**初始化**阶段才开始。

+ **初始化的类型*（和之后的初始化阶段不同）***。在准备阶段，JVM 会为类变量分配内存，并为其初始化。但是这里的初始化指的是**为变量赋予 Java 语言中该数据类型的零值**，而不是用户代码里初始化的值。



### 解析(不重要)



### 初始化(重点)

初始化类型分为两种：

- 类初始化方法。编译器会按照其出现顺序，收集类变量的赋值语句、静态代码块，最终组成类初始化方法。**类初始化方法一般在类初始化的时候执行。**

- 对象初始化方法。编译器会按照其出现顺序，收集成员变量的赋值语句、普通代码块，最后收集构造函数的代码，最终组成对象初始化方法。**对象初始化方法一般在实例化类对象的时候执行。**

JVM 遇到**比较常见的下面 4 种情况**的时候会触发**类初始化**：

+ 遇到new、getstatic、putstatic、invokestatic这四条字节码指令时会触发类初始化。生成这四条指令的常见java代码场景有：

    + 使用new关键字实例化对象的时候；
    + 读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候；
    + 调用一个类的静态方法的时候。

    **注：**

    1. **通过子类引用父类的静态字段，不会导致子类初始化。**
    2. **通过数组定义引用类，不会触发初始化**。（但会触发类`[L<Class>`的初始化，这个类由虚拟机自动生成，由字节码指令newarray触发）
    3. **访问被final修饰的常量**。（在编译阶段会**存入调用类的常量池**，因此实际没有引用到定义该常量的类）

+ 使用 `java.lang.reflect` 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。

+ 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

+ 当虚拟机启动时，**用户需要指定一个要执行的主类（包含main()方法的那个类）**，虚拟机会先初始化这个主类。



**NOTE**: **类初始化和对象初始化是分开的**。比如类`Teacher`继承类`Person`，调用`Teacher`的静态方法只会引发两个类的**类初始化**，当`new Teacher()`实例化一个对象时才会真正引发两个类的对象初始化。



### 使用

JVM 开始从入口方法开始执行用户的程序代码。



### 卸载

当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存。



### 结论

一个类的执行顺序大概可以按照如下步骤：

1. **确定类变量的初始值。**

    在类加载的准备阶段，JVM 会为类变量初始化零值，如果是被 final 修饰的类变量，则直接会被初始成用户想要的值。

2. **初始化入口方法。**

    进入类加载的初始化阶段后，JVM 会寻找整个 main 方法入口，从而初始化 main 方法所在的整个类。

3. **初始化类构造器。**

    JVM 会**按顺序**收集类变量**的赋值语句、静态代码块**，最终组成类构造器由 JVM 执行。

4. **初始化对象构造器。**

    JVM 会按照收集成员变量的**赋值语句、普通代码块，最后收集构造方法**，将它们组成对象构造器，最终由 JVM 执行。



QA：

1. 基本类型

2. 相同维度和元素类型的基本类型数组对应同一个 **Class 对象**

    ```java
    int[] ints = {1, 2};
    int[] ints1 = {1, 2, 3};
    int[] ints2 = {1, 1, 1};
    System.out.println(ints.getClass()==ints1.getClass()); // true
    System.out.println(ints1.getClass()==ints2.getClass()); //true
    ```

    

### 参考资料

1. [两道面试题，带你解析Java类加载机制](https://www.cnblogs.com/chanshuyi/p/the_java_class_load_mechamism.html)
2. [深入理解Java类加载器(一)：Java类加载原理解析](https://blog.csdn.net/justloveyou_/article/details/72217806)
3. [细说类加载器](https://zhuanlan.zhihu.com/p/41672523)