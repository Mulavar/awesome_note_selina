## JVM内存结构

JVM的内存空间可以分为两类：

- 线程共享：
    - 方法区：存放加载的**类信息**、**常量**、**静态变量**等信息。
    - 堆：存放对象实例（**Class类的对象实例在方法区**）。

- 线程隔离：
    - 虚拟机栈：执行每个方法时创建一个栈帧，存有**局部变量表**、**操作数栈**、**动态链接**、**方法出口**等信息。
    - 本地方法栈：native方法的栈。
    - PC（程序计数器）：指定下一条指令为止，执行native方法时为空。



**注**：

1. 核心是方法区和堆，方法区中有一块运行时常量池，用来存储Class文件的常量池信息。
2. 虚拟机栈中的一些信息，如栈帧大小、分配给局部变量的最大内存，都由方法区中记录的信息确定。



## Class文件结构

Class文件格式采用一种类似结构体的伪结构来存储数据，这种伪结构只有两种数据结构：**无符号数**和**表**。

- **无符号数**：以u1、u2、u4、u8分别表示1、2、4、8个字节的无符号数，可以用来描述数字、索引引用等内容。
- **表**：由多个无符号数或其他表构成的复合数据类型，以_info结尾，**整个Class文件本质上就是一个表**。

伪结构如下：

```java
ClassFile {
    // 值固定为 0xCAFEBABE
    u4             magic; 
    
    // 主次版本号表示能处理该类文件的编译器版本范围
    u2             minor_version;
    u2             major_version;
    
    // 常量表个数及常量表(从1开始计数，0x0016实际表示有21个常量表)
    u2             constant_pool_count;
    cp_info        constant_pool[constant_pool_count-1];
    
    // 访问标志
    u2             access_flags;
    
    // 父类、接口等标记
    u2             this_class;
    u2             super_class;
    u2             interfaces_count;
    u2             interfaces[interfaces_count];
    
    // 字段表
    u2             fields_count;
    field_info     fields[fields_count];
    
    // 方法表
    u2             methods_count;
    method_info    methods[methods_count];
    
    // 属性表
    u2             attributes_count;
    attribute_info attributes[attributes_count];
}
```

注：Class文件是由**8个字节**为基础的字节流构成的，这些字节流之间都严格按照规定的顺序排列，并且字节之间不存在任何空隙，**对于超过8个字节的数据，将按照Big-Endian的顺序存储**。



### 常量池(重要)

常量池是Class文件的资源池，主要存放两大类常量：

- 字面量：如文本字符串、final常量值（即static final）
- 符号引用：包括下面三类
    - 类和接口全限定名
    - 字段的名称和描述符
    - 方法的名称和描述符



注：Java文件编译没有链接这一步骤，而是在虚拟机加载Class文件的时候动态链接。因此，Class文件本身不会保存各个方法的内存布局信息，而是在**运行期通过转换符号变量得到真正的内存入口地址**。







## Java的类加载过程

JVM 虚拟机执行 class 字节码的过程可以分为七个阶段：**加载、验证、准备、解析、初始化、使用、卸载。**

这里只讲一下需要了解的加载、验证、准备、初始化几个过程。



### 加载

JVM 的主要目的是将字节码从各个位置（网络、磁盘等）转化为二进制字节流加载到内存中，接着会为这个类在 JVM 的方法区创建一个对应的 **Class 对象**，**这个 Class 对象就是这个类各种数据的访问入口**。具体过程如下：

1. 通过类全限定名获取字节流
2. 将字节流载入转为方法区的运行时数据结构



### 验证

**JVM规范校验**。JVM 会对字节流进行文件格式校验，判断其是否符合 JVM 规范，是否能被当前版本的虚拟机处理。

**代码逻辑校验**。JVM 会对代码组成的数据流和控制流进行校验，确保 JVM 运行该字节码文件后不会出现致命错误。(**IDE或编译阶段的javac也有类似的作用**)



### 准备

完成字节码校验后，JVM开始为**类变量**分配内存并初始化。值得注意的是，**内存分配的对象**和**初始化类型**都有两种：

- **内存分配的对象**：

    - 类变量：被 `static` 修饰的变量
    - 类成员变量

    在准备阶段，JVM 只会为「类变量」分配内存，而不会为「类成员变量」分配内存。「类成员变量」的内存分配需要等到**初始化**阶段才开始。

- **初始化的类型*（和之后的初始化阶段不同）***。在准备阶段，JVM 会为类变量分配内存，并为其初始化。但是这里的初始化指的是**为变量赋予 Java 语言中该数据类型的零值**，而不是用户代码里初始化的值。

    

### 初始化(重点)

初始化类型分为两种：

- 类初始化方法。编译器会按照其出现顺序，收集类变量的赋值语句、静态代码块，最终组成类初始化方法。**类初始化方法一般在类初始化的时候执行。**
- 对象初始化方法。编译器会按照其出现顺序，收集成员变量的赋值语句、普通代码块，最后收集构造函数的代码，最终组成对象初始化方法。**对象初始化方法一般在实例化类对象的时候执行。**

JVM 遇到**比较常见的下面 4 种情况**的时候会触发**类初始化**：

- 遇到new、getstatic、putstatic、invokestatic这四条字节码指令时会触发类初始化。生成这四条指令的常见java代码场景有：

    - 使用new关键字实例化对象的时候；
    - 读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候；
    - 调用一个类的静态方法的时候。

    **注：**

    1. **通过子类引用父类的静态字段，不会导致子类初始化。**
    2. **通过数组定义引用类，不会触发初始化**。（但会触发类`[L<Class>`的初始化，这个类由虚拟机自动生成，由字节码指令newarray触发）
    3. **访问被final修饰的常量**。（在编译阶段会存入调用类的常用池，因此实际没有引用到定义该常量的类）

- 使用 `java.lang.reflect` 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。

- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

- 当虚拟机启动时，**用户需要指定一个要执行的主类（包含main()方法的那个类）**，虚拟机会先初始化这个主类。



**NOTE**: **类初始化和对象初始化是分开的**。比如类`Teacher`继承类`Person`，调用`Teacher`的静态方法只会引发两个类的**类初始化**，当`new Teacher()`实例化一个对象时才会真正引发两个类的对象初始化。



### 结论

一个类的执行顺序大概可以按照如下步骤：

1. **确定类变量的初始值。**

    在类加载的准备阶段，JVM 会为类变量初始化零值，如果是被 final 修饰的类变量，则直接会被初始成用户想要的值。

2. **初始化入口方法。**

    进入类加载的初始化阶段后，JVM 会寻找整个 main 方法入口，从而初始化 main 方法所在的整个类。

3. **初始化类构造器。**

    JVM 会**按顺序**收集类变量**的赋值语句、静态代码块**，最终组成类构造器由 JVM 执行。

4. **初始化对象构造器。**

    JVM 会按照收集成员变量的**赋值语句、普通代码块，最后收集构造方法**，将它们组成对象构造器，最终由 JVM 执行。



