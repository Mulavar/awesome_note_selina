## 基本概念

从JDK1.4开始，Java提供了一系列改进的输入/输出处理的新特性，被统称为NIO(即New I/O)。

NIO支持**面向缓冲区的、基于通道**的IO操作。 NIO将以更加高效的方式进行文件的读写操作。



### 缓冲区Buffer

在NIO库中，所有数据都是**用缓冲区处理的**。在读取数据时，它是直接读到缓冲区中的； 在写入数据时，它也是

写入到缓冲区中的；任何时候访问 NIO 中的数据，都是将它放到缓冲区中。

在面向流I/O系统中，所有数据都是直接写入或者直接将数据读取到Stream对象中。



### 通道Channel

通道是双向的，**通过一个Channel既可以进行读，也可以进行写；**

而Stream只能进行单向操作，**通过一个Stream只能进行读或者写。**

**通道是一个对象，通过它可以读取和写入数据，所有数据都通过Buffer对象来处理**。我们永远不会将字节直接写入通道中，相反是将数据写入包含一个或者多个字节的缓冲区。同样不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。



### 选择器Selector

**Selector能够检测多个注册的通道上是否有事件发生**，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来，只是用一个单线程就可以管理多个通道，也就是管理多个连接。

优势：可以**在一个线程中处理多个连接**，不用使用多个线程，减少了线程切换上下文的开销。





## 非阻塞与阻塞

传统IO的问题在于阻塞，即当调用read方法时，如果没有数据，这个线程会阻塞直到读取到数据。这时为了读取其他连接的数据，我们需要另起线程，这会有大量的线程上下文切换开销。

引入NIO后，在非阻塞模式下，**read方法不管有没有读到数据，都会直接返回。我们必须不停调用read方法尝试获取数据**，而引入selector后，就解决了多连接的问题，selector会采集各个通道（Channel）的状态，当**注册了该selector的channel发生了某事件（注册时让selector监听）时，selector就会去处理**。

那NIO如何获取完整的数据？因为每次读取是非阻塞的（阻塞交给后台线程实现），可能一段数据传输到一半被我们read了，因为nio的数据处理相对而言较复杂，netty就是基于nio开发的框架。



[java nio阻塞与非阻塞](https://zhuanlan.zhihu.com/p/53918989)

[selector阻塞原理](https://blog.csdn.net/god8816/article/details/54320053)

