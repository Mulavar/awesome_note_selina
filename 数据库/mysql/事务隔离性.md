# 隔离性

## 1.1基本概念

即每个事务在执行的时候，都**认为只有自己在对数据库进行操作**，对其他事务的操作不可见。



## 1.2隔离等级

隔离性具有四个等级：

- 未提交读（read uncommitted）：事务之间完全不隔离，会出现**脏读、不可重复读、幻读；**
- 提交读（read committed）：事务读取的数据，都是别的事务已经提交了的，这种情况禁止了脏读，但还是会有不可重复读、幻读；
- 可重复读（repeatable read）：在上一个级别的基础上，**保证不会在一个事务内两次select同一条数据会出现变化，即是别的事务对你select的对象进行update操作不会影响**。但是，**如果是insert操作，在这个隔离级别还是会受到影响**。事务A开启事务，并select一段有范围的数据，然后事务B开启事务，在先前A事务select的那段有范围的数据中insert一条数据，然后提交事务，接着事务A再select出来这段数据，发现数据多了一条，这种情况叫幻读（Phantom Read）
- 序列化读（serializable）：每个事务都可以认为只有它自己在操作数据库。



## 1.3脏读、幻读、不可重复读的概念

- 脏读：脏读是指一个事务中**访问到了另外一个事务未提交的数据；**
- 不可重复读：一个事务读取同一条记录2次，得到的**数据结果**不一致（update）；
- 幻读：一个事务读取2次，得到的**记录条数**不一致（insert或delete）；



## 1.4实现方式

### 两阶段加锁(2PL)

我们将一个事务分为两个阶段，**lock阶段**和**unlock阶段**，lock永远在unlock之前，则如图

![image-20200212010347644](../../resources/mysql-2PL.png)

由于实际情况很难确定什么时候可以解锁，所以实际用的是2PL的略加修改版本，**S2PL（Strict-2PL）。**对于这种情况，我们只有在事务commit或rollback时才会解锁，其余所有都是加锁阶段，如图

![image-20200212010733346](../../resources/msql-S2PL.png)

我们还可以按照数据热点对SQL进行优化排序，让对热点数据的操作更靠后，这样做有两个好处：

1. 减少热点数据被锁的时间，可以显著提高吞吐量
2. 避免死锁



[参考资料](https://yq.aliyun.com/articles/626848)

### MVCC

