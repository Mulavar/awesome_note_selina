### 1. C&C++的宏定义的作用、应用场景，为什么有大量的宏定义？



### 2. 什么是可重入锁？Java的锁超时怎么使用？

可重入锁指获得该锁的线程在内部可以再次获得该锁而不会报错。



### 3. 反射和new关键字创建对象有什么区别？为什么使用反射？

反射创建实际上把new分解成了两步：

1. 调用class的加载方法加载某个类（`Class.forName()`)
2. 通过 newInstance() 创建

区别：

| newInstance      | new                        |
| ---------------- | -------------------------- |
| 弱类型（Object） | 强类型                     |
| 低效率           | 相对高效                   |
| 只能调用无参构造 | 可以调用任意public构造方法 |

如果没有反射机制，每次增加类时，**都需要把类的class文件放在类路径中，再修改源代码new这个类**产生对应类的对象；

有了反射机制后，**只需要在配置文件写上相应的类名称，再通过io流读取配置文件中的类名，即可通过class.forName()方法找出相应的class文件并加载进内存中，再通过newInstance()方法创建一个对象**，此时的对象是一个Object类型的对象，需要转换成相对应的类类型。这样就可以在不修改源代码的情况下通过修改配置文件进行功能的更新和扩展了。



### 4. HashMap 迭代器修改值的问题？

### 5. Maven **代理和私服的区别**？

私服指搭建在局域网内部的仓库，本身是一个仓库，也可以提供许多内部组织的插件和依赖。

代理是用于拦截远程仓库请求，从自己这边找出构件返回给用户。

很多私服搭建工具往往也提供mirror服务。



### 6. 原生态类型有没有泛型参数

没有，通过反射泛型获取不到



### 7. 什么是大小端？

大端：高位字节在低位地址，和字符串显示顺序一致

小端：高位字节在高位地址

一般操作系统都是小端，而通讯协议是大端的。

Java和所有的网络通讯协议都是使用Big-Endian的编码。



### 8. CGO 调C函数和GO函数是否在一个goroutine里执行？

不是。如go调c会新建一个线程执行c的程序。



### 9. go的json库解析？

go的json序列化时**无法对小写变量（私有）做序列化**。



### 10. java的编码和go的编码

   分清内码（internal encoding）和外码（external encoding）。

   1、内码 :某种语言运行时，其char和string在内存中的编码方式。

   2、外码 :除了内码，皆是外码。（**源代码编译产生的目标代码文件（可执行文件或class文件）中的编码方式属于外码。**）

   java的**内码的char是utf-16编码（java的char是2字节）**，而外码是采用了utf-8。

   java的外码使用的是改进版utf-8，标准utf-8的表示是1~4个字节，而改进版使用6个字节表示标准utf-8使用4个字节表示的字符，且null采用双字节(char(0))来表示。

   Java的class文件采用UTF8来存储字符，也就是说，class中字符占1～6个字节。

   Java序列化时，字符也采用UTF8编码，占1～6个字节。



### 11. 既然有 HTTP 请求，为什么还要用 RPC 调用？

   使用http请求做rpc调用有以下缺点：

   1. 包含大量http头，**有用信息占比少**
   2. 由于信息体较大，**效率低**
   3. 使用HTTP协议**调用远程方法比较复杂**，要封装各种参数名和参数值。



### 12. 如何判断Java对象是否已经死亡？

这跟具体的GC算法有关，以引用计数法为例，**对象引用计数为0**的时候就是死亡状态，而根据可达性算法分析，则会以所有**GC Roots**作为起点，开始搜索，如果搜索的路径上没有该对象的话，则证明该对象已经死亡。



### 13. 关于基本类型数组的类？

数组类是一种特殊的类，他没有具体的Class文件定义，而是通过虚拟机创建，而相同维度和元素类型的数组类对应同一个 **Class 对象**。

```java
int[] ints = {1, 2};
int[] ints1 = {1, 2, 3};
int[] ints2 = {1, 1, 1};
System.out.println(ints.getClass()==ints1.getClass()); // true
System.out.println(ints1.getClass()==ints2.getClass()); //true
```



### 14. jdk源码用到了哪些设计模式?

例如：

- Java.io 装饰器模式
- java.lang.reflect.Proxy 代理模式
- java.lang.StringBuilder 建造者模式



### 15. serialVersionUID作用？

假如不显式定义，jvm会根据类信息自动计算，那如果类文件做过修改，就会因为不兼容而无法反序列化（**但其实需要序列化的字段可能都没有改变，我们的期望是可以反序列化**），同样由于各机器jvm版本不一致可能也会导致自动生成的serialVersionUID不一样而无法反序列化。



### 16. 浅拷贝和深拷贝区别

- 浅拷贝 浅拷贝是按位拷贝对象，**它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝**。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。
- 深拷贝 **深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存**。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。 现在为了要在clone对象时进行深拷贝， 那么就要Clonable接口，覆盖并实现clone方法，除了调用父类中的clone方法得到新的对象， 还要将该类中的引用变量也clone出来。**如果只是用Object中默认的clone方法，是浅拷贝的**。